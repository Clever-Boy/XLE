// Copyright 2015 XLGAMES Inc.
//
// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#if !defined(RESOLVE_UNSHADOWED_PSH)
#define RESOLVE_UNSHADOWED_PSH

#include "../Lighting/ResolverInterface.h"
#include "../Lighting/LightShapes.h"
#include "../Lighting/ShadowTypes.h"
#include "resolveutil.h"
#include "../System/LoadGBuffer.h"
#include "../Colour.h" // for LightingScale

#if HAS_SCREENSPACE_AO==1
    Texture2D<float>	AmbientOcclusion : register(t5);
#endif

cbuffer LightBuffer
{
	LightDesc Light;
}

ILightResolver      MainResolver;
ICascadeResolver    MainCascadeResolver;
IShadowResolver     MainShadowResolver;

float4 main(
    float4 position : SV_Position,
	float2 texCoord : TEXCOORD0,
	float3 viewFrustumVector : VIEWFRUSTUMVECTOR,
	SystemInputs sys) : SV_Target0
{
	int2 pixelCoords = position.xy;
	GBufferValues sample = LoadGBuffer(position.xy, sys);

    LightSampleExtra sampleExtra;
    sampleExtra.screenSpaceOcclusion = 1.f;
	#if HAS_SCREENSPACE_AO==1
        sampleExtra.screenSpaceOcclusion = LoadFloat1(AmbientOcclusion, pixelCoords, GetSampleIndex(sys));
    #endif

    LightScreenDest screenDest;
    screenDest.pixelCoords = pixelCoords;
    screenDest.sampleIndex = GetSampleIndex(sys);

    // Note -- we could pre-multiply (miniProj.W/FarClip) into the view frustum vector to optimise this slightly...?
    float worldSpaceDepth = GetWorldSpaceDepth(pixelCoords, GetSampleIndex(sys));
    float3 worldPosition = WorldSpaceView + (worldSpaceDepth / FarClip) * viewFrustumVector;

    float3 result = MainResolver.Resolve(
        sample, sampleExtra, Light, worldPosition,
        normalize(-viewFrustumVector), screenDest);

    // Also calculate the shadowing -- (though we could skip it if the lighting is too dim here)
    float shadow = 1.f;		// area outside of all cascades is considered outside of shadow...
    CascadeAddress cascade = MainCascadeResolver.Resolve(worldPosition, texCoord, worldSpaceDepth);
    if (cascade.cascadeIndex >= 0)
        shadow = MainShadowResolver.Resolve(cascade, screenDest);

	return float4((LightingScale*shadow)*result, 1.f);
}

#endif
