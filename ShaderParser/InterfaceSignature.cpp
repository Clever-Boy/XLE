// Copyright 2015 XLGAMES Inc.
//
// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#include "InterfaceSignature.h"
#include "Grammar/ShaderLexer.h"
#include "Grammar/ShaderParser.h"
#include "../Utility/StringUtils.h"

#include "../Utility/StringFormat.h"
#include "../Utility/Streams/Stream.h"
#include "../ConsoleRig/OutputStream.h"
#include <assert.h>

namespace ShaderSourceParser
{
    void Warning(const char format[], ...)
    {
        va_list args;
        va_start(args, format);
        ConsoleRig::GetWarningStream().WriteNullTerm((const utf8*)"{Color:ff7f7f}");
        PrintFormatV(&ConsoleRig::GetWarningStream(), format, args);
        va_end(args);
    }

    static std::string AsString(ANTLR3_STRING* antlrString)
    {
        auto tempString = antlrString->toUTF8(antlrString);
        auto result = std::string((char*)tempString->chars);
        tempString->factory->destroy(tempString->factory, tempString);
        return result;
    }

        ////////////////////////////////////////////////////////////

    namespace Detail
    {
        #undef free

        template <typename Type> 
            void DestroyAntlrObject(Type* object) 
            {
                if (object) object->free(object);
            }

        template <typename Type>
            class AntlrWrapper
        {
        public:
            AntlrWrapper(Type* antlrObj) : _antlrObj(antlrObj) {}
            ~AntlrWrapper()                 { DestroyAntlrObject(_antlrObj); }
            operator Type*()                { return _antlrObj; }
            operator const Type*() const    { return _antlrObj; }
            operator bool() const           { return !!_antlrObj; }
            Type* operator->()              { return _antlrObj; }
            const Type* operator->() const  { return _antlrObj; }
        private:
            Type*        _antlrObj;
        };

        template<> void DestroyAntlrObject<>(ANTLR3_INPUT_STREAM* object)
        {
            if (object) object->close(object);
        }

    }

    typedef Detail::AntlrWrapper<ShaderLexer>       ShaderLexer_SmartPtr;
    typedef Detail::AntlrWrapper<ShaderParser>      ShaderParser_SmartPtr;
    typedef Detail::AntlrWrapper<struct ANTLR3_COMMON_TOKEN_STREAM_struct>  TokenStream_SmartPtr;
    typedef Detail::AntlrWrapper<struct ANTLR3_INPUT_STREAM_struct>         InputStream_SmartPtr;

    namespace AntlrHelper
    {
        pANTLR3_BASE_TREE GetChild(pANTLR3_BASE_TREE node, ANTLR3_UINT32 childIndex)
        {
            return pANTLR3_BASE_TREE(node->getChild(node, childIndex));
        }

        pANTLR3_COMMON_TOKEN GetToken(pANTLR3_BASE_TREE node)
        {
            return node->getToken(node);
        }

        ANTLR3_UINT32 GetType(pANTLR3_COMMON_TOKEN token)
        {
            return token->getType(token);
        }
    }

    ShaderFragmentSignature     BuildShaderFragmentSignature(const char sourceCode[], size_t sourceCodeLength)
    {
        InputStream_SmartPtr input = antlr3StringStreamNew((uint8*)sourceCode, ANTLR3_ENC_8BIT, (unsigned)sourceCodeLength, (uint8*)"InputStream");
        if (!input) {
	        throw std::exception("Unable to create the input stream due to malloc() failure\n");
        }

        ShaderLexer_SmartPtr lxr = ShaderLexerNew(input);	    // CLexerNew is generated by ANTLR
        if (!lxr) {
			throw std::exception("Unable to create the lexer due to malloc() failure\n");
        }

        TokenStream_SmartPtr tstream = antlr3CommonTokenStreamSourceNew( ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
        if (!tstream) {
			throw std::exception("Out of memory trying to allocate token stream\n");
        }

        ShaderParser_SmartPtr psr = ShaderParserNew(tstream);  // CParserNew is generated by ANTLR3
        if (!psr) {
			throw std::exception("Out of memory trying to allocate parser\n");
        }

        auto abstractSyntaxTree = psr->fx_file(psr);

        if (psr->pParser->rec->state->errorCount > 0) {
            Warning("Tree : %s\n", abstractSyntaxTree.tree->toStringTree(abstractSyntaxTree.tree)->chars);
            ConsoleRig::GetWarningStream().Flush();
            throw Exceptions::CompileError(XlDynFormatString("The parser returned %d errors, tree walking aborted.\n", psr->pParser->rec->state->errorCount).c_str());
        }

        auto treeRoot = abstractSyntaxTree.tree;

        ShaderFragmentSignature result;

        auto childCount = treeRoot->getChildCount(treeRoot);
        for (auto i=0u; i<childCount; ++i) {
            auto node        = pANTLR3_BASE_TREE(treeRoot->getChild(treeRoot, i));
            auto token       = node->getToken(node);
            auto tokenType   = token->getType(token);

            if (tokenType == FUNCTION) {
                    
                    // Function objects should be
                    //      (return type) (function name)
                    //      (FORMAL_ARG)*
                    //      BLOCK

                auto functionChildCount = node->getChildCount(node);
                if (functionChildCount >= 2) {
                    FunctionSignature functionResult;

                    auto returnTypeNode      = pANTLR3_BASE_TREE(node->getChild(node, 0));
                    auto functionNameNode    = pANTLR3_BASE_TREE(node->getChild(node, 1));

                    functionResult._returnType  = AsString(returnTypeNode->toString(returnTypeNode));
                    functionResult._name        = AsString(functionNameNode->toString(functionNameNode));
                        
                    for (unsigned q=2; q<functionChildCount; ++q) {
                        auto functionNode    = pANTLR3_BASE_TREE(node->getChild(node, q));
                        auto token           = functionNode->getToken(functionNode);
                        auto tokenType       = token->getType(token);
                        if (tokenType == FORMAL_ARG) {
                            auto childCount          = functionNode->getChildCount(functionNode);
                            if (childCount >= 2) {
                                auto typeNode        = pANTLR3_BASE_TREE(functionNode->getChild(functionNode, 0));
                                auto nameNode        = pANTLR3_BASE_TREE(functionNode->getChild(functionNode, 1));

                                FunctionSignature::Parameter parameter;
                                parameter._name     = AsString(nameNode->toString(nameNode));
                                parameter._type     = AsString(typeNode->toString(typeNode));
                                parameter._direction = FunctionSignature::Parameter::In;

                                    // look for a DIRECTION_OUT or DIRECTION_IN_OUT child
                                    // this will exist after the type and name (if it exists at all)
                                for (unsigned c=2; c<childCount; ++c) {
                                    using namespace AntlrHelper;
                                    auto tokenType = GetType(GetToken(GetChild(functionNode, c)));
                                    if (tokenType == DIRECTION_OUT) {
                                        parameter._direction = FunctionSignature::Parameter::Out;
                                    } else if (tokenType == DIRECTION_OUT) {
                                        parameter._direction = FunctionSignature::Parameter::In | FunctionSignature::Parameter::Out;
                                    }
                                }
                                
                                functionResult._parameters.push_back(std::move(parameter));
                            }
                        }
                    }

                    result._functions.push_back(std::move(functionResult));
                }
            } else if (tokenType == STRUCT) {

                //
                //  Structs are simple...
                //      (name)
                //      (VARIABLE)*
                //      where VARIABLE is:
                //          (VARIABLE type (VARIABLE_NAME name (SUBSCRIPT ...)? (SEMANTIC ...)? (e)?)*)
                //
                //      Note that we're not distinguishing between "struct" and "cbuffer"... they both
                //      come out the same. But the shader syntax will be slightly different in each
                //      case.
                //

                auto childCount = node->getChildCount(node);
                if (childCount>= 1) {
                    ParameterStructSignature str;

                    auto nameNode = pANTLR3_BASE_TREE(node->getChild(node, 0));
                    str._name = AsString(nameNode->toString(nameNode));

                    for (unsigned q=1; q<childCount; ++q) {
                        auto uniformNode     = pANTLR3_BASE_TREE(node->getChild(node, q));
                        auto token           = uniformNode->getToken(uniformNode);
                        auto tokenType       = token->getType(token);
                        if (tokenType == VARIABLE) {

                                //
                                //      This is a "VARIABLE" node. There is a type name,
                                //      and then a list of variables of this type. Note
                                //      that HLSL doesn't have "*" and "&", etc -- so it's
                                //      not too complex (not to mention function pointers...)
                                //

                            auto uniformChildCount = uniformNode->getChildCount(uniformNode);
                            if (uniformChildCount >= 2) {

                                auto typeNameNode   = pANTLR3_BASE_TREE(uniformNode->getChild(uniformNode, 0));
                                auto uniformType    = AsString(typeNameNode->toString(typeNameNode));

                                for (unsigned n=1; n<uniformChildCount; ++n) {
                                    auto nameNode   = pANTLR3_BASE_TREE(uniformNode->getChild(uniformNode, n));
                                    auto token      = nameNode->getToken(nameNode);
                                    auto tokenType  = token->getType(token);
                                    if (tokenType == VARIABLE_NAME) {

                                        auto nameNodeChildCount = nameNode->getChildCount(nameNode);
                                        if (nameNodeChildCount >= 1) {

                                            auto variableNamePart = pANTLR3_BASE_TREE(nameNode->getChild(nameNode, 0));
                                            auto variableName = AsString(variableNamePart->toString(variableNamePart));
                                            std::string semantic;

                                                //  look for a "SEMANTIC" node attached
                                                //      if there are multiple, it's an error.. but just use the first valid
                                            for (unsigned w=1; w<nameNodeChildCount; ++w) {
                                                auto partNode   = pANTLR3_BASE_TREE(nameNode->getChild(nameNode, n));
                                                auto token      = partNode->getToken(partNode);
                                                auto tokenType  = token->getType(token);
                                                if (tokenType == SEMANTIC) {
                                                    if (partNode->getChildCount(partNode) >= 1) {
                                                        auto semanticNamePart = pANTLR3_BASE_TREE(partNode->getChild(partNode, 0));
                                                        semantic = AsString(semanticNamePart->toString(semanticNamePart));
                                                        break;
                                                    }
                                                }
                                            }

                                                //  We know everything about the parameter now
                                                //      ... so just add it to the list
                                            ParameterStructSignature::Parameter p;
                                            p._name = variableName;
                                            p._type = uniformType;
                                            p._semantic = semantic;
                                            str._parameters.push_back(p);

                                        }

                                    }
                                }
                            }
                        }
                    }

                    if (str._parameters.size()) {
                        result._parameterStructs.push_back(std::move(str));
                    }

                }
            }
        }

        return result;
    }

        ////////////////////////////////////////////////////////////

    FunctionSignature::FunctionSignature() {}
    FunctionSignature::~FunctionSignature() {}
    FunctionSignature::FunctionSignature(FunctionSignature&& moveFrom)
    :   _returnType(std::move(moveFrom._returnType))
    ,   _name(std::move(moveFrom._name))
    ,   _parameters(std::move(moveFrom._parameters))
    {}

    FunctionSignature& FunctionSignature::operator=(FunctionSignature&& moveFrom) never_throws
    {
        _returnType = std::move(moveFrom._returnType);
        _name = std::move(moveFrom._name);
        _parameters = std::move(moveFrom._parameters);
        return *this;
    }

        ////////////////////////////////////////////////////////////

    ParameterStructSignature::ParameterStructSignature() {}
    ParameterStructSignature::~ParameterStructSignature() {}
    ParameterStructSignature::ParameterStructSignature(ParameterStructSignature&& moveFrom)
    :   _name(std::move(moveFrom._name))
    ,   _parameters(std::move(moveFrom._parameters))
    {

    }

    ParameterStructSignature& ParameterStructSignature::operator=(ParameterStructSignature&& moveFrom) never_throws
    {
        _name = std::move(moveFrom._name);
        _parameters = std::move(moveFrom._parameters);
        return *this;
    }

        ////////////////////////////////////////////////////////////

    ShaderFragmentSignature::ShaderFragmentSignature() {}
    ShaderFragmentSignature::~ShaderFragmentSignature() {}
    ShaderFragmentSignature::ShaderFragmentSignature(ShaderFragmentSignature&& moveFrom)
    : _functions(std::move(moveFrom._functions))
    , _parameterStructs(std::move(moveFrom._parameterStructs))
    {}
    
    ShaderFragmentSignature& ShaderFragmentSignature::operator=(ShaderFragmentSignature&& moveFrom) never_throws
    {
        _functions = std::move(moveFrom._functions);
        _parameterStructs = std::move(moveFrom._parameterStructs);
        return *this;
    }

    namespace Exceptions
    {
        CompileError::CompileError(const char label[]) never_throws
        : BasicLabel(label)
        {}
    }

}

#include <stdexcept>
void myDisplayRecognitionError (void * recognizer, void * tokenNames)
{
    pANTLR3_BASE_RECOGNIZER r = (pANTLR3_BASE_RECOGNIZER)recognizer;
    pANTLR3_UINT8 * t = (pANTLR3_UINT8 *)tokenNames;
    ShaderSourceParser::Warning("Error from antlr");
}

